     1                                  ; segment is 0x0000 throught out the program. DS == ES == 0
     2                                  
     3                                  ;*********************************************************
     4                                  ;               macro
     5                                  ;*********************************************************
     6                                  %include "../include/define.s"
     1                              <1> BOOT_LOAD equ 0x07C00                  ; load address of boot program
     2                              <1> BOOT_SIZE equ (1024 * 8)              ; size of boot code(byte)
     3                              <1> SECT_SIZE equ (512)                   ; size of sector; 1 sector = 512bytes = 4096bits
     4                              <1> BOOT_SECT equ (BOOT_SIZE / SECT_SIZE) ; number of sectors for boot program
     7                                  %include "../include/macro.s"
     1                              <1> %macro cdecl 1-*.nolist
     2                              <1>   %rep %0 -1 
     3                              <1> 	  push %{-1:-1}      ; last arg
     4                              <1> 		%rotate -1         ; rotate to right ->
     5                              <1> 	%endrep
     6                              <1> 	%rotate -1           ; return args to as it used be
     7                              <1> 
     8                              <1> 	call %1
     9                              <1> 
    10                              <1> 	%if 1 < %0
    11                              <1> 		add sp, (__BITS__ >> 3) * (%0 - 1)     ;dump stqck (16(2byte) or 32(4byte)) * (number of args)
    12                              <1> 	%endif
    13                              <1> %endmacro
    14                              <1> 
    15                              <1> 
    16                              <1> struc drive
    17 00000000 <res 00000002>      <1>      .no     resw   1   ; drive number
    18 00000002 <res 00000002>      <1>      .cyln   resw   1   ; cylinder
    19 00000004 <res 00000002>      <1>      .head   resw   1   ; head
    20 00000006 <res 00000002>      <1>      .sect   resw   1   ; sector
    21                              <1> endstruc
     8                                  
     9                                  			 ORG BOOT_LOAD                ; tell assembla where this program is loaded
    10                                  
    11                                  ;*********************************************************
    12                                  ;               entry point
    13                                  ;*********************************************************
    14                                  
    15                                  entry:
    16 00000000 EB58                           jmp ipl        ; Initial Program Loader;
    17                                  
    18                                       ; BPB(BIOS Parameter Block)
    19 00000002 90<rept>                		   times 90 - ($ - $$) db 0x90  ; 0x90 -> NOP
    20                                  
    21                                  ipl: ; IPL
    22 0000005A FA                             cli                          ; disable interruption
    23                                  
    24 0000005B B80000                  			 mov ax, 0x0000
    25 0000005E 8ED8                    			 mov ds, ax
    26 00000060 8EC0                    			 mov es, ax
    27 00000062 8ED0                    			 mov ss, ax
    28 00000064 BC007C                  			 mov sp, BOOT_LOAD
    29                                  
    30 00000067 FB                      			 sti                          ; enable inerruption
    31                                  
    32 00000068 8816[B800]                     mov [BOOT + drive.no], dl    ; store boot drive
    33                                  
    34                                  
    35                                  ;*********************************************************
    36                                  ;               display string
    37                                  ;*********************************************************
    38 0000006C 68[9900]E84E0083C4-            cdecl puts, .s0
    38 00000074 02                 
    39                                  
    40                                  
    41                                  ;*********************************************************
    42                                  ;               load next 512 bytes
    43                                  ;               Sector load: AH = 0x02, INT = 0x13
    44                                  ;*********************************************************
    45 00000075 BB0F00                           mov bx, BOOT_SECT -1            ; number of boot sectors left
    46 00000078 B9007E                  				 mov cx, BOOT_LOAD + SECT_SIZE   ; next address to load
    47                                  
    48 0000007B 515368[B800]E89B00-     				 cdecl read_chs, BOOT, bx, cx
    48 00000083 83C406             
    49                                  
    50 00000086 39D8                             cmp ax, bx                      ; if(AX != BX) // AH = status code(0 if success), AL = number of sectors loaded, BX = number of sectors left to load for boot program
    51 00000088 740C                    .10Q:    jz .10E
    52 0000008A 68[A600]E8300083C4-     .10T:    cdecl puts, .e0
    52 00000092 02                 
    53 00000093 E84900                  				 call reboot
    54                                  .10E:
    55                                  
    56 00000096 E94C02                  				 jmp stage_2
    57                                  
    58                                  
    59                                  ;*********************************************************
    60                                  ;               data
    61                                  ;*********************************************************
    62 00000099 426F6F74696E672E2E-     .s0    db "Booting...", 0x0A, 0x0D, 0    ; 0x0A = LF, 0x0D = CR
    62 000000A2 2E0A0D00           
    63 000000A6 4572726F723A736563-     .e0    db "Error:sector read", 0
    63 000000AF 746F72207265616400 
    64                                  
    65                                  ALIGN 2, db 0
    66                                  BOOT:                      ; info related to boot drive
    67                                    istruc drive
    68 000000B8 0000                    	  at drive.no,   dw 0    ; drive number
    69 000000BA 0000                    	  at drive.cyln, dw 0    ; cylinder number
    70 000000BC 0000                    	  at drive.head, dw 0    ; head number
    71 000000BE 0200                    	  at drive.sect, dw 2    ; sector number
    72                                    iend
    73                                  
    74                                  
    75                                  ;*********************************************************
    76                                  ;               modules
    77                                  ;*********************************************************
    78                                  %include "../modules/real/puts.s"
     1                              <1> ; void puts(str); str -> address of string. 0x00 is the end of a string
     2                              <1> 
     3                              <1> puts:
     4                              <1>     ; stackframe
     5                              <1> 											; 4 -> str
     6                              <1> 											; 2 -> IP
     7 000000C0 55                  <1> 			push bp         ; 0
     8 000000C1 89E5                <1> 			mov bp, sp
     9                              <1> 
    10                              <1> 		; store registers
    11 000000C3 50                  <1> 			push ax
    12 000000C4 53                  <1> 			push bx
    13 000000C5 56                  <1> 			push si
    14                              <1> 
    15                              <1> 		; get arg
    16 000000C6 8B7604              <1> 		  mov si, [bp + 4]
    17                              <1> 
    18                              <1>     ; start function
    19 000000C9 B40E                <1> 			mov ah, 0x0E            ; tele type 1 charactor output
    20 000000CB BB0000              <1> 			mov bx, 0x0000          ; page number & color
    21                              <1> 
    22 000000CE FC                  <1> 			cld                     ; DF = 0; increment address
    23                              <1> 
    24                              <1> .10L:
    25 000000CF AC                  <1>       lodsb                  ; AL = [SI]; SI += 1(byte)
    26                              <1> 
    27 000000D0 3C00                <1>       cmp al, 0
    28 000000D2 7404                <1> 			je .10E
    29                              <1> 
    30 000000D4 CD10                <1> 			int 0x10                ; video BIOS call
    31 000000D6 EBF7                <1> 			jmp .10L
    32                              <1> 
    33                              <1> .10E:
    34                              <1>     ; return regisgters
    35 000000D8 5E                  <1> 		  pop si
    36 000000D9 5B                  <1> 		  pop bx
    37 000000DA 58                  <1> 			pop ax
    38                              <1> 
    39                              <1> 		; discard stackframe
    40 000000DB 89EC                <1> 		  mov sp, bp
    41 000000DD 5D                  <1> 			pop bp
    42                              <1> 
    43 000000DE C3                  <1> 			ret
    44                              <1> 
    45                              <1> 
    79                                  %include "../modules/real/reboot.s"
     1                              <1> reboot:
     2 000000DF 68[FB00]E8DBFF83C4- <1>          cdecl puts, .s0
     2 000000E7 02                  <1>
     3                              <1> 
     4                              <1> 
     5                              <1> ;*********************************************************
     6                              <1> ;               wait for input
     7                              <1> ;*********************************************************
     8 000000E8 B410                <1> .10L:    mov ah, 0x10     ; input : AH = 0x10, INT 0x16 -> AL = input
     9 000000EA CD16                <1>          int 0x16
    10                              <1> 
    11 000000EC 3C20                <1> 				 cmp al, ' '       ; ZF == 0;
    12 000000EE 75F8                <1> 				 jne .10L         ; while(!ZF);
    13                              <1> 
    14 000000F0 68[1901]E8CAFF83C4- <1> 				 cdecl puts, .s1
    14 000000F8 02                  <1>
    15                              <1> 
    16                              <1> 
    17                              <1> ;*********************************************************
    18                              <1> ;               reboot
    19                              <1> ;*********************************************************
    20 000000F9 CD19                <1> 				 int 0x19         ; BIOS(0x19) -> reboot
    21                              <1> 
    22 000000FB 0A0D50757368205350- <1> .s0 db 0x0A, 0x0D, "Push SPACE key to reboot...", 0
    22 00000104 414345206B65792074- <1>
    22 0000010D 6F207265626F6F742E- <1>
    22 00000116 2E2E00              <1>
    23 00000119 0A0D0A0D00          <1> .s1 db 0x0A, 0x0D, 0x0A, 0x0D, 0
    80                                  %include "../modules/real/read_chs.s"
     1                              <1> ; read_chs(drive, sect, dst);
     2                              <1> ;          drive   address of struc drive
     3                              <1> ;          sect    number of sectors to read
     4                              <1> ;          dst     address to put what's read
     5                              <1> 
     6                              <1> read_chs:
     7                              <1> ;*********************************************************
     8                              <1> ;                 stackframe
     9                              <1> ;*********************************************************
    10                              <1>                                     ;  8 -> dst
    11                              <1>                                     ;  6 -> sect
    12                              <1>                                     ;  4 -> parameter buffer; what's that?
    13                              <1>                                     ;  2 -> IP
    14 0000011E 55                  <1>        push bp
    15 0000011F 89E5                <1> 			 mov bp, sp
    16                              <1> 
    17 00000121 6A03                <1> 			 push 3                       ; retry = 3
    18 00000123 6A00                <1> 			 push 0                       ; sector count = 0
    19                              <1> 
    20                              <1> 
    21                              <1> ;*********************************************************
    22                              <1> ;                 store registers
    23                              <1> ;*********************************************************
    24 00000125 53                  <1>        push bx
    25 00000126 51                  <1> 			 push cx
    26 00000127 52                  <1> 			 push dx
    27 00000128 06                  <1> 			 push es
    28 00000129 56                  <1> 			 push si
    29                              <1> 
    30                              <1> 
    31                              <1> ;*********************************************************
    32                              <1> ;                 start function
    33                              <1> ;*********************************************************
    34 0000012A 8B7604              <1>        mov si, [bp + 4]             ; SI = parameter buffer; what's that?
    35                              <1> 
    36                              <1> 
    37                              <1> ;*********************************************************
    38                              <1> ;                 configurate CX(optimize for BIOS call)
    39                              <1> ;*********************************************************
    40 0000012D 8A6C02              <1>        mov ch, [si + drive.cyln + 0]      ; CH = cylinder number(bottom byte); why + 0?
    41 00000130 8A4C03              <1>        mov cl, [si + drive.cyln + 1]      ; CH = cylinder number(upper byte); why + 1?
    42 00000133 C0E106              <1> 			 shl cl, 6                          ; CL <<= 6; shift to leftest 2 bits so that sector number can use the rest of 6
    43 00000136 0A4C06              <1> 			 or cl, [si + drive.sect]           ; CL |= sector number; using "or" not to lose 2bits which is already there
    44                              <1> 
    45                              <1> 
    46                              <1> ;*********************************************************
    47                              <1> ;                 read sector
    48                              <1> ;                 Sector load: AH = 0x02, INT = 0x13
    49                              <1> ;                 output: CF = 0,1; success or failure
    50                              <1> ;                         AH = status code
    51                              <1> ;                         AL = number of sectors read
    52                              <1> ;*********************************************************
    53 00000139 8A7404              <1>        mov dh, [si + drive.head]          ; DH = head number
    54 0000013C 8A14                <1> 			 mov dl, [si + 0]                   ; DL = drive number; why not drive.no?
    55 0000013E B80000              <1> 			 mov ax, 0x0000
    56 00000141 8EC0                <1> 			 mov es, ax                         ; ES = 0x000; not sure why this is set as ES is referred by DI
    57 00000143 8B5E08              <1> 			 mov bx, [bp + 8]                   ; BX = dst; offset
    58                              <1> 
    59                              <1> .10L:                                     ; do {
    60 00000146 B402                <1>        mov ah, 0x02                       ; BIOS call for sector load: AH = 0x02, INT = 0x13
    61 00000148 8A4606              <1> 		   mov al, [bp + 6]                   ; number of sectors to read
    62                              <1> 
    63 0000014B CD13                <1> 			 int 0x13                           ; BIOS call for sector load: AH = 0x02, INT = 0x13
    64 0000014D 7304                <1> 		   jnc .11E                           ; if(CF) { // CF = BIOS(0x13, 0x02) success(0) or not(1)
    65                              <1> 
    66 0000014F B000                <1> 			 mov al, 0                          ;   reset AL; AL = sectors to read
    67 00000151 EB0C                <1> 			 jmp .10E                           ;   break; // don't retry if CF == 1
    68                              <1> 			                                    ; }
    69                              <1> .11E:
    70 00000153 3C00                <1>        cmp al, 0                          ; if (a sector was read) {
    71 00000155 7508                <1> 			 jne .10E                           ;   break;
    72                              <1>                                           ; }
    73 00000157 B80000              <1> 			 mov ax,0                           ; ret = 0; set return value. AH = status code, AL = sectors read
    74 0000015A FF4FFE              <1> 			 dec word [bx - 2]                  ; retry--;
    75 0000015D 75E7                <1> 			 jnz .10L                           ; } while(retry);
    76                              <1> .10E:
    77 0000015F B400                <1>        mov ah, 0                           ; reset status code
    78                              <1> 
    79                              <1> 
    80                              <1> ;*********************************************************
    81                              <1> ;                 return registers
    82                              <1> ;*********************************************************
    83 00000161 5E                  <1>        pop si
    84 00000162 07                  <1> 			 pop es
    85 00000163 5A                  <1> 			 pop dx
    86 00000164 59                  <1> 			 pop cx
    87 00000165 5B                  <1> 			 pop bx
    88                              <1> 
    89                              <1> 
    90                              <1> ;*********************************************************
    91                              <1> ;                 discard stackframe
    92                              <1> ;*********************************************************
    93 00000166 89EC                <1>        mov sp, bp
    94 00000168 5D                  <1> 			 pop bp
    95 00000169 C3                  <1> 			 ret
    81                                  
    82                                  
    83                                  ;*********************************************************
    84                                  ;               boot flag(first 512 byte)
    85                                  ;*********************************************************
    86 0000016A 00<rept>                       times 510 - ($ - $$) db 0x00
    87 000001FE 55AA                           db 0x55, 0xAA
    88                                  
    89                                  
    90                                  ;*********************************************************
    91                                  ; info acquired when real mode
    92                                  ;*********************************************************
    93                                  FONT:
    94 00000200 0000                    .seg: dw 0
    95 00000202 0000                    .off: dw 0
    96                                  
    97                                  
    98                                  ;*********************************************************
    99                                  ; modules(they're put after the first 512 bytes because they're not called in the 1st stage)
   100                                  ;*********************************************************
   101                                  %include "../modules/real/itoa.s"
     1                              <1> ; void itoa(num, buff, sise, radix, flag);
     2                              <1> ;           num   -> number to convert
     3                              <1> ;           buff  -> address of buffer to store
     4                              <1> ;           size  -> size of buffer to store
     5                              <1> ;           radix -> radix. fundamental number
     6                              <1> ;           flags -> B0: treat value as signed var
     7                              <1> ;                    B1: add sign +/-
     8                              <1> ;                    B2: fill with 0
     9                              <1> 
    10                              <1> itoa:
    11                              <1> ;*********************************************************
    12                              <1> ;                 stackframe
    13                              <1> ;*********************************************************
    14                              <1>                                     ; 12 -> flag
    15                              <1>                                     ; 10 -> radix
    16                              <1>                                     ;  8 -> size
    17                              <1>                                     ;  6 -> buff
    18                              <1>                                     ;  4 -> num
    19                              <1>                                     ;  2 -> IP
    20 00000204 55                  <1>        push bp
    21 00000205 89E5                <1> 			 mov bp, sp
    22                              <1> 
    23                              <1> 
    24                              <1> ;*********************************************************
    25                              <1> ;                 store registers
    26                              <1> ;*********************************************************
    27 00000207 50                  <1>        push ax
    28 00000208 53                  <1>        push bx
    29 00000209 51                  <1>        push cx
    30 0000020A 52                  <1>        push dx
    31 0000020B 56                  <1>        push si
    32 0000020C 57                  <1>        push di
    33                              <1> 
    34                              <1> 
    35                              <1> ;*********************************************************
    36                              <1> ;                 get args
    37                              <1> ;*********************************************************
    38 0000020D 8B4604              <1>        mov ax, [bp + 4]             ; val  = num
    39 00000210 8B7606              <1>        mov si, [bp + 6]             ; dst  = buffer address
    40 00000213 8B4E08              <1>        mov cx, [bp + 8]             ; size = buffer size
    41                              <1> 
    42 00000216 89F7                <1> 			 mov di, si                   ; DI = tail of buffer
    43 00000218 01CF                <1> 			 add di, cx                   ; DI = dst + size
    44 0000021A 4F                  <1> 			 dec di                       ; last index = dst + size - 1
    45                              <1> 
    46 0000021B 8B5E0C              <1> 			 mov bx, word [bp + 12]       ; flags
    47                              <1> 
    48                              <1> 
    49                              <1> ;*********************************************************
    50                              <1> ; decide it is singed or not, then set to display sign if value is smaller than 0
    51                              <1> ;*********************************************************
    52 0000021E F7C30100            <1>       test bx, 0b0001              ; if(flags & 0x01) B0: treat value as signed var
    53 00000222 7408                <1> .10Q: je .10E                      ; {
    54 00000224 83F800              <1>       cmp ax, 0                    ;   if(AX < 0)
    55 00000227 7D03                <1> .12Q: jge .12E                     ;   {
    56 00000229 83CB02              <1>       or bx, 0b0010                ;     flags ||= 0x02; B1: display sign +/-
    57                              <1> .12E:                              ;   }
    58                              <1> .10E:                              ; }
    59                              <1> 
    60                              <1> 
    61                              <1> ;*********************************************************
    62                              <1> ; see if sign is set to be displayed, then then add + or -
    63                              <1> ;*********************************************************
    64 0000022C F7C30200            <1>       test bx, 0b0010              ; if(flags & 0x02) B1: add sign +/-
    65 00000230 7410                <1> .20Q: je .20E                      ; {
    66 00000232 83F800              <1>       cmp ax, 0                    ;   if(AX < 0)
    67 00000235 7D07                <1> .22Q:  jge .22F                    ;   {
    68 00000237 F7D8                <1> 	    neg ax                       ;     val *= -1;
    69 00000239 C6042D              <1> 			mov [si], byte '-'           ;     *dst = '-';
    70 0000023C EB03                <1> 			jmp .22E                     ;   } else {
    71 0000023E C6042B              <1> .22F: mov [si], byte '+'           ;     *dst = '+';
    72                              <1>                                    ;   }
    73 00000241 49                  <1> .22E: dec cx                       ;   size--; because sign uses 1 byte
    74                              <1> .20E:                              ; }
    75                              <1> 
    76                              <1> 
    77                              <1> ;*********************************************************
    78                              <1> ; convert to ASCII, iterate each number by dividing AX(num) by radix till AX is zero
    79                              <1> ;*********************************************************
    80 00000242 8B5E0A              <1> 			mov bx, [bp + 10]            ; radix
    81                              <1> 
    82 00000245 BA0000              <1> .30L: mov dx, 0
    83 00000248 F7F3                <1>       div bx                       ; div(16bit) -> AX = DX:AX(32bit) / BX, DX = DX:AX(32bit) % BX
    84                              <1> 
    85 0000024A 89D6                <1> 			mov si, dx                   ; probably DX can't be used as index. need some research
    86 0000024C 8A94[7402]          <1> 			mov dl, byte [.ascii + si]    ; DL = ASCII[DX];
    87                              <1> 
    88 00000250 8815                <1> 			mov [di], dl                 ; *dst = DL; (DI = dst + size at first iteration)
    89 00000252 4F                  <1> 			dec di                       ; dst--;
    90                              <1> 
    91 00000253 83F800              <1> 			cmp ax, 0
    92 00000256 E0ED                <1> 			loopnz .30L                  ; while(AX);
    93                              <1> .30E:
    94                              <1> 
    95                              <1> 
    96                              <1> ;*********************************************************
    97                              <1> ; fill empty bytes
    98                              <1> ;*********************************************************
    99 00000258 83F900              <1> 			cmp cx, 0
   100 0000025B 740D                <1> .40Q: je .40E
   101 0000025D B020                <1>       mov al, ' '
   102 0000025F 837E0C04            <1> 			cmp [bp + 12], word 0b0100   ; if(flags & 0x04) | specifing "word" because the left operand is memory address(type is ambiguous)
   103 00000263 7502                <1> .42Q: jne .42E
   104 00000265 B030                <1>       mov al, '0'
   105                              <1> 
   106 00000267 FD                  <1> .42E: std                          ; DF = 1;(-)
   107 00000268 F3AA                <1>       rep stosb                    ; while(--CX) *DI-- = AL;
   108                              <1> .40E:
   109                              <1> 
   110                              <1> 
   111                              <1> ;*********************************************************
   112                              <1> ; return registers
   113                              <1> ;*********************************************************
   114 0000026A 5F                  <1>       pop di
   115 0000026B 5E                  <1> 			pop si
   116 0000026C 5A                  <1> 			pop dx
   117 0000026D 59                  <1> 			pop cx
   118 0000026E 5B                  <1> 			pop bx
   119 0000026F 58                  <1> 			pop ax
   120                              <1> 
   121                              <1> 
   122                              <1> ;*********************************************************
   123                              <1> ; discard stackframe
   124                              <1> ;*********************************************************
   125 00000270 89EC                <1>       mov sp, bp
   126 00000272 5D                  <1> 			pop bp
   127 00000273 C3                  <1> 			ret
   128                              <1> 
   129 00000274 303132333435363738- <1> .ascii db "0123456789ABCDEF"        ; convertion table
   129 0000027D 39414243444546      <1>
   102                                  %include "../modules/real/get_drive_param.s"
     1                              <1> ; get_drive_param(drive)
     2                              <1> ;   drive -> address of drive struct
     3                              <1> ;   returns
     4                              <1> ;     success  -> other than 0
     5                              <1> ;     failutre -> 0
     6                              <1> get_drive_param:
     7                              <1> ;                               4 -> parameter buffer; what's that?
     8                              <1> ;                               2 -> IP
     9 00000284 55                  <1> 			  push bp
    10 00000285 89E5                <1> 			  mov bp, sp
    11                              <1> 
    12                              <1> 
    13                              <1> ;*********************************************************
    14                              <1> ; store registers
    15                              <1> ;*********************************************************
    16 00000287 53                  <1>         push bx
    17 00000288 51                  <1>         push cx
    18 00000289 06                  <1>         push es
    19 0000028A 56                  <1>         push si
    20 0000028B 57                  <1>         push di
    21                              <1> 
    22                              <1> 
    23                              <1> ;*********************************************************
    24                              <1> ; start task
    25                              <1> ;*********************************************************
    26 0000028C 8B7604              <1>        mov si, [bp + 4]               ; SI = parameter buffer
    27                              <1> 
    28                              <1> 
    29                              <1> ;*********************************************************
    30                              <1> ; Disk Service: fetch drive parameter.
    31                              <1> ; input: INT = 0x13, AL = 0x08, DL = drive number
    32                              <1> ; output: CF = status(0,1),
    33                              <1> ;         AH = return code,
    34                              <1> ;         CL(7,6) = number of cylinder,
    35                              <1> ;         CH      = number of cylinder,
    36                              <1> ;         CL(5~0) = number of sector,
    37                              <1> ;         DH = number of head,
    38                              <1> ;         DL = number of drive,
    39                              <1> ;         ES:DI = address of disk base table
    40                              <1> ;*********************************************************
    41 0000028F B80000              <1> 			 mov ax, 0                      ; initialize a disk base table pointer. what's that?
    42 00000292 8EC0                <1> 			 mov es, ax                     ; ES = 0
    43 00000294 89C7                <1> 			 mov di, ax                     ; DI = 0
    44                              <1> 
    45 00000296 B408                <1> 			 mov ah, 0x08                   ; AH = 0x08
    46 00000298 8A14                <1> 			 mov dl, [si + drive.no]        ; DL = drive number
    47 0000029A CD13                <1> 			 int 0x13
    48 0000029C 721B                <1> .10Q:  jc .10F                       ; if(CF==0)
    49 0000029E 88C8                <1> .10T:  mov al, cl                    ; AX = number of sectors
    50 000002A0 83E03F              <1>        and ax, 0x3F                  ; only the right 6 bits. 0x3F == 00111111
    51                              <1> 
    52 000002A3 C0E906              <1> 			 shr cl, 6                     ; CX = number of cylinders; the left 2 bits
    53 000002A6 C1C908              <1> 			 ror cx, 8                     ; the 2 bits left in CL comes to the right 2 bits of CH, so rotate 8bits
    54 000002A9 41                  <1> 			 inc cx                        ; cylinder size is (address + 1) because cylinder starts from 0
    55                              <1> 
    56 000002AA 0FB6DE              <1> 			 movzx bx, dh                  ; BX = number of heads(1 base table) // expand 8bits to 16bits after mov by movzx;
    57 000002AD 43                  <1> 			 inc bx                        ; head size is (address + 1) because head starts from 0
    58                              <1> 
    59 000002AE 894C02              <1>        mov [si + drive.cyln], cx     ; cyln = number of cylinders
    60 000002B1 895C04              <1>        mov [si + drive.head], bx     ; head = number of heads
    61 000002B4 894406              <1>        mov [si + drive.sect], ax     ; sect = number of sectors
    62                              <1> 
    63 000002B7 EB03                <1> 			 jmp .10E
    64                              <1> 
    65 000002B9 B80000              <1> .10F:  mov ax, 0                     ; AX(AH) = 0 = failure
    66                              <1> .10E:
    67                              <1> 
    68                              <1> 
    69                              <1> ;*********************************************************
    70                              <1> ; return registers
    71                              <1> ;*********************************************************
    72 000002BC 5F                  <1>        pop di
    73 000002BD 5E                  <1>        pop si
    74 000002BE 07                  <1>        pop es
    75 000002BF 59                  <1>        pop cx
    76 000002C0 5B                  <1>        pop bx
    77                              <1> 
    78                              <1> 
    79                              <1> ;*********************************************************
    80                              <1> ; discard stackframe
    81                              <1> ;*********************************************************
    82 000002C1 89EC                <1>        mov sp, bp
    83 000002C3 5D                  <1> 			 pop bp
    84                              <1> 
    85 000002C4 C3                  <1> 			 ret
   103                                  %include "../modules/real/get_font_adr.s"
     1                              <1> ; void get_font_adr(adr);
     2                              <1> ;    adr -> address of font address
     3                              <1> get_font_adr:
     4                              <1>                        ; 4 -> address of font address
     5                              <1> 											 ; 2 -> IP
     6 000002C5 55                  <1> 		push bp
     7 000002C6 89E5                <1> 		mov bp, sp
     8                              <1> 
     9 000002C8 50                  <1> 		push ax
    10 000002C9 53                  <1> 		push bx
    11 000002CA 56                  <1> 		push si
    12 000002CB 06                  <1> 		push es
    13 000002CC 55                  <1> 		push bp            ; why it doesn't affect BP's role as a central place?
    14                              <1> 
    15                              <1> 
    16                              <1> ;*********************************************************
    17                              <1> ;                 get args
    18                              <1> ;*********************************************************
    19 000002CD 8B7604              <1> 		mov si, [bp + 4]    ; dst = address of font address
    20                              <1> 
    21                              <1> 
    22                              <1> ;*********************************************************
    23                              <1> ;                 get font address
    24                              <1> ;*********************************************************
    25 000002D0 B83011              <1> 		mov ax, 0x1130      ;BIOS service to get font address
    26 000002D3 B706                <1> 		mov bh, 0x06        ; 8 x 16 fond(vga/mcga). How does 6 represent 8 x 16?
    27 000002D5 CD10                <1> 		int 10h             ; ES:BP = FONT ADDRESS
    28                              <1> 
    29                              <1> 
    30                              <1> ;*********************************************************
    31                              <1> ;                 store font address
    32                              <1> ;*********************************************************
    33 000002D7 8C04                <1> 		mov [si + 0], es    ; dst[0] = segment
    34 000002D9 896C02              <1> 		mov [si + 2], bp    ; dst[1] = offset
    35                              <1> 
    36                              <1> 
    37                              <1> ;*********************************************************
    38                              <1> ; return registers
    39                              <1> ;*********************************************************
    40 000002DC 5D                  <1>       pop bp
    41 000002DD 07                  <1>       pop es
    42 000002DE 5E                  <1> 			pop si
    43 000002DF 5B                  <1> 			pop bx
    44 000002E0 58                  <1> 			pop ax
    45                              <1> 
    46                              <1> 
    47                              <1> ;*********************************************************
    48                              <1> ; discard stackframe
    49                              <1> ;*********************************************************
    50 000002E1 89EC                <1>       mov sp, bp
    51 000002E3 5D                  <1> 			pop bp
    52 000002E4 C3                  <1> 			ret
   104                                  
   105                                  
   106                                  ;*********************************************************
   107                                  ;               2nd stage of boot procedure
   108                                  ;*********************************************************
   109 000002E5 68[5F03]E8D5FD83C4-     stage_2: cdecl puts, .s0
   109 000002ED 02                 
   110                                  
   111                                  
   112                                  ;*********************************************************
   113                                  ;               get drive parameter
   114                                  ;*********************************************************
   115 000002EE 68[B800]E890FF83C4-              cdecl get_drive_param, BOOT          ; get_drive_param(DX, BOOT.CYLN); why 2 args?
   115 000002F6 02                 
   116 000002F7 83F800                  				 cmp ax, 0                            ; if(AX==0) // get_drive_param set AX to 0 if not succeeded
   117 000002FA 750C                    .10Q:    jne .10E
   118 000002FC 68[9503]E8BEFD83C4-     .10T:    cdecl puts, .e0
   118 00000304 02                 
   119 00000305 E8D7FD                           call reboot
   120                                  .10E:
   121                                  
   122                                  
   123                                  ;*********************************************************
   124                                  ;               display drive info
   125                                  ;*********************************************************
   126 00000308 A1[B800]                         mov ax, [BOOT + drive.no]            ; AX = boot drive
   127 0000030B 6A046A106A0268-         				 cdecl itoa, ax, .p1, 2, 16, 0b0100
   127 00000312 [7603]50E8ECFE83C4-
   127 0000031A 0A                 
   128 0000031B A1[BA00]                         mov ax, [BOOT + drive.cyln]
   129 0000031E 6A046A106A0468-         				 cdecl itoa, ax, .p2, 4, 16, 0b0100
   129 00000325 [7E03]50E8D9FE83C4-
   129 0000032D 0A                 
   130 0000032E A1[BC00]                         mov ax, [BOOT + drive.head]
   131 00000331 6A046A106A0268-         				 cdecl itoa, ax, .p3, 2, 16, 0b0100
   131 00000338 [8803]50E8C6FE83C4-
   131 00000340 0A                 
   132 00000341 A1[BE00]                         mov ax, [BOOT + drive.sect]          ; AX = sectors per track
   133 00000344 6A046A106A0268-         				 cdecl itoa, ax, .p4, 2, 16, 0b0100
   133 0000034B [9003]50E8B3FE83C4-
   133 00000353 0A                 
   134 00000354 68[6D03]E866FD83C4-     				 cdecl puts, .s1                      ; we define 0 as the end of string, so it renders all the way to .p4
   134 0000035C 02                 
   135                                  
   136                                  
   137                                  ;*********************************************************
   138                                  ;               move to 3rd stage
   139                                  ;*********************************************************
   140 0000035D EB51                             jmp stage_3
   141                                  
   142                                  
   143                                  ;*********************************************************
   144                                  ;               data
   145                                  ;*********************************************************
   146 0000035F 326E64205374616765-     .s0 db "2nd Stage..", 0x0A, 0x0D, 0
   146 00000368 2E2E0A0D00         
   147                                  
   148 0000036D 2044726976653A3078      .s1 db " Drive:0x"
   149 00000376 20202C20433A3078        .p1 db "  , C:0x"
   150 0000037E 202020202C20483A30-     .p2 db "    , H:0x"
   150 00000387 78                 
   151 00000388 20202C20533A3078        .p3 db "  , S:0x"
   152 00000390 20200A0D00              .p4 db "  ", 0x0A, 0x0D, 0
   153                                  
   154 00000395 43616E277420676574-     .e0 db "Can't get drive parameter.", 0
   154 0000039E 206472697665207061-
   154 000003A7 72616D657465722E00 
   155                                  
   156                                  
   157                                  ;*********************************************************
   158                                  ;               3rd stage of boot procedure
   159                                  ;*********************************************************
   160                                  stage_3:
   161 000003B0 68[F303]E80AFD83C4-         cdecl puts, .s0
   161 000003B8 02                 
   162 000003B9 68[0002]E806FF83C4-         cdecl get_font_adr, FONT      ; get BIOS's font address
   162 000003C1 02                 
   163                                  
   164                                  
   165                                  ;*********************************************************
   166                                  ;               display font address
   167                                  ;*********************************************************
   168 000003C2 6A046A106A0468-             cdecl itoa, word [FONT.seg], .p1, 4, 16, 0b0100
   168 000003C9 [1004]FF36[0002]E8-
   168 000003D0 32FE83C40A         
   169 000003D5 6A046A106A0468-             cdecl itoa, word [FONT.off], .p2, 4, 16, 0b0100
   169 000003DC [1504]FF36[0202]E8-
   169 000003E3 1FFE83C40A         
   170 000003E8 68[0104]E8D2FC83C4-         cdecl puts, .s1
   170 000003F0 02                 
   171                                  
   172                                  
   173                                  ;*********************************************************
   174                                  ;               the end of the boot procedure
   175                                  ;*********************************************************
   176 000003F1 EBFE                        jmp $
   177                                  
   178                                  
   179                                  ;*********************************************************
   180                                  ;               data
   181                                  ;*********************************************************
   182 000003F3 337264205374616765-     .s0: db "3rd Stage..", 0x0A, 0x0D, 0
   182 000003FC 2E2E0A0D00         
   183                                  
   184 00000401 20466F6E7420616464-     .s1: db " Font address ="
   184 0000040A 72657373203D       
   185 00000410 5A5A5A5A3A              .p1: db "ZZZZ:"
   186 00000415 5A5A5A5A0A0D00          .p2: db "ZZZZ", 0x0A, 0x0D, 0
   187                                  
   188 0000041C 0A0D00                      db 0x0A, 0x0D, 0
   189                                  
   190                                  
   191                                  ;*********************************************************
   192                                  ; padding to make this program 8,000 bytes
   193                                  ;*********************************************************
   194 0000041F 00<rept>                         times BOOT_SIZE - ($ - $$) db 0
